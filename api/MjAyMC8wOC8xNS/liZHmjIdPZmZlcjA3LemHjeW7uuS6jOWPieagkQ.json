{"title":"剑指 Offer 07.重建二叉树","date":"2020-08-15T13:15:05.000Z","date_formatted":{"ll":"Aug 15, 2020","L":"08/15/2020","MM-DD":"08-15"},"thumbnail":"/images/thumbnail/8.jpg","link":"2020/08/15/剑指Offer07-重建二叉树","comments":true,"tags":["LeetCode","剑指offer","树","深度优先搜索"],"categories":["剑指offer"],"updated":"2020-08-15T14:32:47.307Z","content":"<h2 id=\"题目\">题目<a title=\"#题目\" href=\"#题目\"></a></h2>\n<p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>\n<p>例如，给出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">前序遍历 preorder  [3,9,20,15,7]</span><br><span class=\"line\">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure>\n<p>返回如下的二叉树：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  3</span><br><span class=\"line\"> &#x2F; \\</span><br><span class=\"line\">9  20</span><br><span class=\"line\">  &#x2F;  \\</span><br><span class=\"line\"> 15   7</span><br></pre></td></tr></table></figure>\n<p>限制：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0 &lt;&#x3D; 节点个数 &lt;&#x3D; 5000</span><br></pre></td></tr></table></figure>\n<h2 id=\"解题思路\">解题思路<a title=\"#解题思路\" href=\"#解题思路\"></a></h2>\n<h3 id=\"思路一\">思路一<a title=\"#思路一\" href=\"#思路一\"></a></h3>\n<ol>\n<li><code>preorder[0]</code> 显然为 <code>root</code> 节点。</li>\n<li>从 <code>inorder</code> 中找到值为 <code>preoder[0]</code> 的下标 <code>i</code>。</li>\n<li>对于以 <code>preorder[0]</code> 为 <code>root</code> 节点的树来说，在 <code>inorder</code> 中的区间 $[0, i - 1]$ 为左子树节点值，区间 $[i + 1, inorder.length - 1]$ 为右子树的节点值。</li>\n<li>从第 $3$ 点中也能得出左子树的节点数为 <code>i</code> 个，右子树的节点数为 <code>inorder.length - i</code> 个。</li>\n<li>从 $4$ 点中可以得出在 <code>preoder</code> 中，区间 $[1, i]$ 可以划分为左子树的节点，区间 $[i + 1, preorder.length - 1]$ 可以划分为右子树的节点。</li>\n<li>基于以上结论，我们可以递归的构建这颗树。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number[]&#125;</span> <span class=\"variable\">preorder</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number[]&#125;</span> <span class=\"variable\">inorder</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;TreeNode&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> buildTree = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">preorder, inorder</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!preorder.length || !inorder.length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> root = <span class=\"keyword\">new</span> TreeNode(preorder[<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"keyword\">const</span> i = inorder.indexOf(preorder[<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"comment\">// 递归构建左右子树</span></span><br><span class=\"line\">    root.left = buildTree(preorder.slice(<span class=\"number\">1</span>, i + <span class=\"number\">1</span>), inorder.slice(<span class=\"number\">0</span>, i))</span><br><span class=\"line\">    root.right = buildTree(preorder.slice(i + <span class=\"number\">1</span>), inorder.slice(i + <span class=\"number\">1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","next":{"title":"剑指Offer05.替换空格","link":"2020/08/15/剑指Offer05-替换空格"},"plink":"https://pigpigever.github.io/2020/08/15/剑指Offer07-重建二叉树/","toc":[{"id":"题目","title":"题目","index":"1"},{"id":"解题思路","title":"解题思路","index":"2","children":[{"id":"思路一","title":"思路一","index":"2.1"}]}],"copyright":{"author":"Tonychen","link":"<a href=\"https://pigpigever.github.io/2020/08/15/剑指Offer07-重建二叉树/\" title=\"剑指 Offer 07.重建二叉树\">https://pigpigever.github.io/2020/08/15/剑指Offer07-重建二叉树/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}